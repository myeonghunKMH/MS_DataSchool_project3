const mysql = require('mysql2/promise');

function toInt(v, fallback) {
  const n = parseInt(String(v ?? '').trim(), 10);
  return Number.isFinite(n) ? n : fallback;
}

function makePool(dbName) {
  if (!dbName) throw new Error('makePool: database name is required');

  const pool = mysql.createPool({
    host: process.env.DB_HOST,
    port: toInt(process.env.DB_PORT, 3306),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: dbName,

    waitForConnections: true,
    connectionLimit: toInt(process.env.DB_POOL_MAX, 10),
    queueLimit: 0,

    // Î¨∏ÏûêÏó¥Î°ú ÎÇ†Ïßú Î∞õÍ∏∞(ÌÉÄÏûÑÏ°¥/ÏßÅÎ†¨Ìôî ÏïàÏ†Ñ)
    dateStrings: true,

    // Ïª§ÎÑ•ÏÖò Ïú†ÏßÄ(ÌôòÍ≤ΩÏóê Îî∞Îùº Î¨¥ÏãúÎê† Ïàò ÏûàÏùå)
    enableKeepAlive: true,
    keepAliveInitialDelay: 0,
  });

  // Î∂ÄÌåÖ Ïãú Í∞ÑÎã® Ïó∞Í≤∞ ÌÖåÏä§Ìä∏ Î°úÍ∑∏
  pool.query('SELECT 1').then(
    () => console.log(`[DB] connected: ${dbName}`),
    (err) => console.error(`[DB] connection failed: ${dbName}`, err?.message || err)
  );

  return pool;
}

// === ÌíÄ 3Í∞ú ÏÉùÏÑ± ===
// Í∏∞Ï°¥ ÏÑúÎπÑÏä§Ïö©(crypto_data) - Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞
const cryptoDbName = process.env.DB_NAME || 'crypto_data';
const pool = makePool(cryptoDbName);

// Í±∞Îûò Ï†ÑÏö©(RT_trading_db) - pending_orders, transactions Îì±
const tradingDbName = process.env.TRADING_DB_NAME || 'RT_trading_db';
const tradingPool = makePool(tradingDbName);

// Q&A Ï†ÑÏö©(qna)
const qnaDbName = process.env.QNA_DB_NAME || 'qna';
const qnaPool = makePool(qnaDbName);

// ÌÇ§ÌÅ¥ÎùΩ DB Ï†ÑÏö©
const keycloakDbName = process.env.KEYCLOAK_DB_NAME || 'keycloak';
const keycloakPool = makePool(keycloakDbName);

// === Ïú†Ìã∏ ===
async function healthcheck(dbPool) {
  try {
    const [rows] = await dbPool.query('SELECT 1 AS ok');
    return rows?.[0]?.ok === 1;
  } catch {
    return false;
  }
}

// === Í∏∞Ï°¥ Ìï®ÏàòÎì§ (Î™®Îëê Í∏∞Ï°¥ 'pool' = crypto_data Î•º ÏÇ¨Ïö©) ===
async function testDBConnection() {
  try {
    const conn = await pool.getConnection();
    conn.release();
    console.log('MariaDB Ïó∞Í≤∞ ÏÑ±Í≥µ');
    return true;
  } catch (err) {
    console.error('MariaDB Ïó∞Í≤∞ Ïã§Ìå®:', err);
    return false;
  }
}

async function findOrCreateUser(profile) {
  const { sub: keycloak_uuid, preferred_username: username } = profile;

  try {
    const [rows] = await pool.query(
      'SELECT * FROM users WHERE keycloak_uuid = ?',
      [keycloak_uuid]
    );
    if (rows.length > 0) {
      return rows[0];
    }

    const [result] = await pool.query(
      'INSERT INTO users (keycloak_uuid, username) VALUES (?, ?)',
      [keycloak_uuid, username]
    );
    const [newUserRows] = await pool.query(
      'SELECT * FROM users WHERE id = ?',
      [result.insertId]
    );
    return newUserRows[0];
  } catch (error) {
    console.error('Error in findOrCreateUser:', error);
    throw error;
  }
}

async function getUserById(keycloak_uuid) {
  if (!keycloak_uuid) return null;
  try {
    const [rows] = await pool.query(
      'SELECT * FROM users WHERE keycloak_uuid = ?',
      [keycloak_uuid]
    );
    return rows.length > 0 ? rows[0] : null;
  } catch (error) {
    console.error('Error in getUserById:', error);
    throw error;
  }
}

async function requestDeletion(userId, token) {
  const expires = new Date(Date.now() + 3600 * 1000); // 1 hour
  await pool.query(
    'UPDATE users SET deletion_token = ?, deletion_token_expires_at = ? WHERE id = ?',
    [token, expires, userId]
  );
}

async function createWithdrawalReason(userId, reason) {
  await pool.query(
    'INSERT INTO withdrawal_reasons (user_id, reason) VALUES (?, ?)',
    [userId, reason]
  );
}

async function confirmDeletion(token) {
  const [rows] = await pool.query(
    'SELECT * FROM users WHERE deletion_token = ? AND deletion_token_expires_at > NOW()',
    [token]
  );
  if (rows.length === 0) {
    return null;
  }
  const user = rows[0];
  const scheduledDate = new Date(Date.now() + 14 * 24 * 3600 * 1000); // 14 days
  await pool.query(
    'UPDATE users SET status = ?, deletion_scheduled_at = ?, deletion_token = NULL, deletion_token_expires_at = NULL WHERE id = ?',
    ['deletion_scheduled', scheduledDate, user.id]
  );
  return user;
}

async function cancelDeletion(userId) {
  await pool.query(
    "UPDATE users SET status = 'active', deletion_scheduled_at = NULL, deletion_token = NULL, deletion_token_expires_at = NULL WHERE id = ?",
    [userId]
  );
}

async function findUsersToDelete() {
  const [rows] = await pool.query(
    "SELECT * FROM users WHERE status = 'deletion_scheduled' AND deletion_scheduled_at < NOW()"
  );
  return rows;
}

async function deleteUser(userId) {
  await pool.query('DELETE FROM users WHERE id = ?', [userId]);
}

async function scheduleDeletionImmediately(userId) {
  const scheduledDate = new Date(Date.now() + 14 * 24 * 3600 * 1000); // 14 days
  await pool.query(
    'UPDATE users SET status = ?, deletion_scheduled_at = ? WHERE id = ?',
    ['deletion_scheduled', scheduledDate, userId]
  );
}

// === ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ===
// - Í∏∞Ï°¥ ÏÑúÎ≤Ñ ÏΩîÎìú Ìò∏Ìôò: pool Í∑∏ÎåÄÎ°ú export
// - Q&A Ï†ÑÏö© ÌíÄ Ï∂îÍ∞Ä: qnaPool
module.exports = {
  pool, // Í∏∞Ï°¥(crypto_data)
  qnaPool, // Ïã†Í∑ú(qna)
  testDBConnection,
  findOrCreateUser,
  getUserById,
  requestDeletion,
  createWithdrawalReason,
  confirmDeletion,
  cancelDeletion,
  findUsersToDelete,
  deleteUser,
  scheduleDeletionImmediately,
  // Ïú†Ìã∏
  healthcheck,
};


// ============== Í±∞Îûò Í¥ÄÎ†® Í∏∞Îä• Ï∂îÍ∞Ä ===============

// KRW Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
const KRWUtils = {
  toInteger(amount) {
    const num = Number(amount) || 0;
    return Math.floor(Math.abs(num)) * Math.sign(num);
  },

  calculateTotal(price, quantity) {
    const total = Number(price) * Number(quantity);
    return this.toInteger(total);
  },

  parseNumber(value) {
    if (typeof value === "string") {
      return Number(value.replace(/,/g, "")) || 0;
    }
    return Number(value) || 0;
  },

  processBalance(balance) {
    return {
      ...balance,
      krw_balance: this.toInteger(balance.krw_balance),
    };
  },

  processTransaction(transaction) {
    return {
      ...transaction,
      price: this.toInteger(transaction.price),
      total_amount: this.toInteger(transaction.total_amount),
    };
  }
};

// ÏÇ¨Ïö©Ïûê Í±∞Îûò Í¥ÄÎ†® Ìï®ÏàòÎì§
async function getUserByUsername(username) {
  try {
    const [rows] = await pool.execute(
      "SELECT id FROM users WHERE username = ?",
      [username]
    );
    return rows[0]?.id || null;
  } catch (error) {
    console.error("getUserByUsername Ïò§Î•ò:", error);
    return null;
  }
}

async function getUserBalance(username) {
  try {
    const [rows] = await pool.execute(`
      SELECT krw_balance, btc_balance, eth_balance, xrp_balance
      FROM users
      WHERE username = ?
    `, [username]);
    return rows[0] || null;
  } catch (error) {
    console.error("getUserBalance Ïò§Î•ò:", error);
    return null;
  }
}

async function getUserTransactions(userId, limit = 50, offset = 0) {
  try {
    const [rows] = await tradingPool.execute(`
      SELECT market, side, type, price, quantity, total_amount, created_at
      FROM transactions 
      WHERE user_id = ? 
      ORDER BY created_at DESC 
      LIMIT ? OFFSET ?
    `, [userId, parseInt(limit), parseInt(offset)]);
    return rows;
  } catch (error) {
    console.error("getUserTransactions Ïò§Î•ò:", error);
    return [];
  }
}

async function getUserPendingOrders(userId) {
  try {
    const [rows] = await tradingPool.execute(`
      SELECT id, market, side, order_type, price, quantity, remaining_quantity, 
             total_amount, status, created_at
      FROM pending_orders 
      WHERE user_id = ? AND status IN ('pending', 'partial')
      ORDER BY created_at DESC
    `, [userId]);
    return rows;
  } catch (error) {
    console.error("getUserPendingOrders Ïò§Î•ò:", error);
    return [];
  }
}

async function getMarketPendingOrders(market) {
  try {
    const [rows] = await tradingPool.execute(`
      SELECT id, user_id, market, side, order_type, price, quantity, 
             remaining_quantity, total_amount, status, created_at
      FROM pending_orders 
      WHERE market = ? AND status IN ('pending', 'partial') AND remaining_quantity > 0
      ORDER BY 
        CASE WHEN side = 'bid' THEN price END DESC,
        CASE WHEN side = 'ask' THEN price END ASC,
        created_at ASC
    `, [market]);
    return rows;
  } catch (error) {
    console.error("getMarketPendingOrders Ïò§Î•ò:", error);
    return [];
  }
}

async function createPendingOrder(userId, market, side, price, quantity, totalAmount, type) {
  const connection = await tradingPool.getConnection();
  try {
    await connection.beginTransaction();

    const [result] = await connection.execute(`
      INSERT INTO pending_orders 
      (user_id, market, side, order_type, price, quantity, remaining_quantity, total_amount)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      userId,
      market,
      side,
      type,
      KRWUtils.toInteger(price),
      quantity,
      quantity,
      KRWUtils.toInteger(totalAmount),
    ]);

    await connection.commit();
    console.log(`üìù ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏ Îì±Î°ù: ${market} ${side} ${KRWUtils.toInteger(price).toLocaleString()}Ïõê ${quantity}Í∞ú`);

    return {
      orderId: result.insertId,
      status: "pending",
      message: "ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏Ïù¥ Îì±Î°ùÎêòÏóàÏäµÎãàÎã§.",
    };
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}

async function cancelPendingOrder(userId, orderId) {
  const connection = await tradingPool.getConnection();
  try {
    await connection.beginTransaction();

    const [orderRows] = await connection.execute(`
      SELECT market, side, price, remaining_quantity, total_amount, status
      FROM pending_orders 
      WHERE id = ? AND user_id = ? AND status IN ('pending', 'partial') FOR UPDATE
    `, [orderId, userId]);

    if (orderRows.length === 0) {
      throw new Error("Ï∑®ÏÜåÌï† Ïàò ÏûàÎäî Ï£ºÎ¨∏ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.");
    }

    const order = orderRows[0];

    await connection.execute(`
      UPDATE pending_orders 
      SET status = 'cancelled', updated_at = NOW()
      WHERE id = ? AND user_id = ? AND status IN ('pending', 'partial')
    `, [orderId, userId]);

    if (order.side === "bid") {
      const refundAmount = KRWUtils.calculateTotal(order.price, order.remaining_quantity);
      
      await connection.execute(`
        UPDATE users 
        SET krw_balance = krw_balance + ?
        WHERE id = ?
      `, [refundAmount, userId]);

      console.log(`üí∞ Îß§Ïàò Ï£ºÎ¨∏ Ï∑®ÏÜå - KRW ÏûîÍ≥† Î≥µÍµ¨: ${refundAmount.toLocaleString()}Ïõê`);
    } else if (order.side === "ask") {
      const coinName = order.market.split("-")[1].toLowerCase();
      
      await connection.execute(`
        UPDATE users 
        SET ${coinName}_balance = ${coinName}_balance + ?
        WHERE id = ?
      `, [order.remaining_quantity, userId]);

      console.log(`ü™ô Îß§ÎèÑ Ï£ºÎ¨∏ Ï∑®ÏÜå - ${coinName.toUpperCase()} ÏûîÍ≥† Î≥µÍµ¨: ${order.remaining_quantity}Í∞ú`);
    }

    await connection.commit();
    console.log(`‚ùå Ï£ºÎ¨∏ Ï∑®ÏÜå ÏôÑÎ£å: ID ${orderId}`);

    return { message: "Ï£ºÎ¨∏Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§." };
  } catch (error) {
    await connection.rollback();
    console.error("Ï£ºÎ¨∏ Ï∑®ÏÜå Ï≤òÎ¶¨ Ïò§Î•ò:", error);
    throw error;
  } finally {
    connection.release();
  }
}

async function executeTradeTransaction(userId, market, side, finalPrice, finalQuantity, totalAmount, type) {
  const connection = await tradingPool.getConnection();
  try {
    await connection.beginTransaction();

    const coinName = market.split("-")[1].toLowerCase();

    if (side === "bid") {
      await processBuyOrder(connection, userId, coinName, totalAmount, finalQuantity);
    } else {
      await processSellOrder(connection, userId, coinName, finalQuantity, totalAmount);
    }

    await connection.execute(`
      INSERT INTO transactions (user_id, market, side, price, quantity, total_amount, type) 
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `, [userId, market, side, KRWUtils.toInteger(finalPrice), finalQuantity, KRWUtils.toInteger(totalAmount), type]);

    await connection.commit();
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}

async function processBuyOrder(connection, userId, coinName, totalAmount, finalQuantity) {
  // crypto_dataÏóêÏÑú ÏûîÍ≥† ÌôïÏù∏ (pool ÏÇ¨Ïö©)
  const poolConnection = await pool.getConnection();
  try {
    const [balanceRows] = await poolConnection.execute(`
      SELECT krw_balance
      FROM users WHERE id = ? FOR UPDATE
    `, [userId]);

    const currentBalance = KRWUtils.toInteger(balanceRows[0]?.krw_balance || 0);
    const requiredAmount = KRWUtils.toInteger(totalAmount);

    console.log(`üí∞ ÏãúÏû•Í∞Ä Îß§Ïàò ÏûîÍ≥† ÌôïÏù∏ - ÏÇ¨Ïö©Ïûê ID: ${userId}`);
    console.log(`üí∞ ÌòÑÏû¨ ÏûîÍ≥†: ${currentBalance.toLocaleString()}Ïõê`);
    console.log(`üí∞ ÌïÑÏöî Í∏àÏï°: ${requiredAmount.toLocaleString()}Ïõê`);

    if (currentBalance < requiredAmount) {
      throw new Error(`ÏûîÏï°Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§. ÌòÑÏû¨ ÏûîÍ≥†: ${currentBalance.toLocaleString()}Ïõê, ÌïÑÏöî Í∏àÏï°: ${requiredAmount.toLocaleString()}Ïõê`);
    }

    const newKrwBalance = currentBalance - requiredAmount;

    // crypto_dataÏóêÏÑú ÏûîÍ≥† Ï∞®Í∞ê
    await poolConnection.execute(`
      UPDATE users SET krw_balance = ? WHERE id = ?
    `, [newKrwBalance, userId]);

  } finally {
    poolConnection.release();
  }

  // crypto_dataÏóêÏÑú ÏΩîÏù∏ ÏûîÍ≥† Ï¶ùÍ∞Ä
  const cryptoConnection = await pool.getConnection();
  try {
    await cryptoConnection.execute(`
      UPDATE users
      SET ${coinName}_balance = ${coinName}_balance + ?
      WHERE id = ?
    `, [finalQuantity, userId]);
  } finally {
    cryptoConnection.release();
  }
}

async function processSellOrder(connection, userId, coinName, finalQuantity, totalAmount) {
  // crypto_dataÏóêÏÑú ÏûîÍ≥† ÌôïÏù∏ Î∞è ÏóÖÎç∞Ïù¥Ìä∏
  const poolConnection = await pool.getConnection();
  try {
    const [balanceRows] = await poolConnection.execute(`
      SELECT ${coinName}_balance, krw_balance
      FROM users WHERE id = ? FOR UPDATE
    `, [userId]);

    const currentCoinBalance = balanceRows[0]?.[`${coinName}_balance`] || 0;
    const currentKrwBalance = KRWUtils.toInteger(balanceRows[0]?.krw_balance || 0);

    console.log(`üí∞ ÏãúÏû•Í∞Ä Îß§ÎèÑ ÏûîÍ≥† ÌôïÏù∏ - ÏÇ¨Ïö©Ïûê ID: ${userId}`);
    console.log(`üí∞ ÌòÑÏû¨ ${coinName.toUpperCase()} ÏûîÍ≥†: ${currentCoinBalance}Í∞ú`);
    console.log(`üí∞ Îß§ÎèÑ ÏàòÎüâ: ${finalQuantity}Í∞ú`);
    console.log(`üí∞ Î∞õÏùÑ Í∏àÏï°: ${KRWUtils.toInteger(totalAmount).toLocaleString()}Ïõê`);

    if (currentCoinBalance < finalQuantity) {
      throw new Error(`Î≥¥Ïú† ÏΩîÏù∏Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§. ÌòÑÏû¨ ÏûîÍ≥†: ${currentCoinBalance}Í∞ú, Îß§ÎèÑ ÏàòÎüâ: ${finalQuantity}Í∞ú`);
    }

    const addAmount = KRWUtils.toInteger(totalAmount);
    const newKrwBalance = currentKrwBalance + addAmount;

    // crypto_dataÏóêÏÑú ÏûîÍ≥† ÏóÖÎç∞Ïù¥Ìä∏
    await poolConnection.execute(`
      UPDATE users
      SET krw_balance = ?,
          ${coinName}_balance = ${coinName}_balance - ?
      WHERE id = ?
    `, [newKrwBalance, finalQuantity, userId]);

  } finally {
    poolConnection.release();
  }
}

// ============== ÌÇ§ÌÅ¥ÎùΩ ÎèôÍ∏∞Ìôî Ìï®Ïàò Ï∂îÍ∞Ä ===============

// ÌÇ§ÌÅ¥ÎùΩ USER_ENTITYÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
async function getKeycloakUsers() {
  try {
    const [rows] = await keycloakPool.execute(`
      SELECT ID, USERNAME, EMAIL, CREATED_TIMESTAMP, ENABLED
      FROM USER_ENTITY
      WHERE REALM_ID = 'itc'
    `);
    return rows;
  } catch (error) {
    console.error("ÌÇ§ÌÅ¥ÎùΩ ÏÇ¨Ïö©Ïûê Ï°∞Ìöå Ïò§Î•ò:", error);
    return [];
  }
}

// crypto_data.users ÌÖåÏù¥Î∏îÏóêÏÑú Í∏∞Ï°¥ ÌÇ§ÌÅ¥ÎùΩ ÏÇ¨Ïö©Ïûê ÌôïÏù∏
async function getExistingKeycloakUsers() {
  try {
    const [rows] = await pool.execute(`
      SELECT keycloak_uuid, username
      FROM users
      WHERE keycloak_uuid IS NOT NULL
    `);
    return new Set(rows.map(row => row.keycloak_uuid));
  } catch (error) {
    console.error("Í∏∞Ï°¥ ÌÇ§ÌÅ¥ÎùΩ ÏÇ¨Ïö©Ïûê Ï°∞Ìöå Ïò§Î•ò:", error);
    return new Set();
  }
}

// ÌÇ§ÌÅ¥ÎùΩ ÏÇ¨Ïö©ÏûêÎ•º crypto_data.usersÏóê ÎèôÍ∏∞Ìôî
async function syncKeycloakUsers() {
  try {
    console.log("üîÑ ÌÇ§ÌÅ¥ÎùΩ ÏÇ¨Ïö©Ïûê ÎèôÍ∏∞Ìôî ÏãúÏûë...");

    const keycloakUsers = await getKeycloakUsers();
    const existingUsers = await getExistingKeycloakUsers();

    let syncCount = 0;

    for (const kcUser of keycloakUsers) {
      // Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÏÇ¨Ïö©ÏûêÎäî Í±¥ÎÑàÎõ∞Í∏∞
      if (existingUsers.has(kcUser.ID)) {
        continue;
      }

      // ÏÉà ÏÇ¨Ïö©Ïûê ÏÉùÏÑ±
      try {
        const [result] = await pool.execute(`
          INSERT INTO users (keycloak_uuid, username, created_at)
          VALUES (?, ?, NOW())
        `, [kcUser.ID, kcUser.USERNAME]);

        // Ï¥àÍ∏∞ Í±∞Îûò ÏûîÍ≥† ÏÑ§Ï†ï
        await pool.execute(`
          UPDATE users
          SET
            krw_balance = 10000000,
            btc_balance = 0.00000000,
            eth_balance = 0.00000000,
            xrp_balance = 0.00000000
          WHERE id = ?
        `, [result.insertId]);

        syncCount++;
        console.log(`‚úÖ ÏÉà ÏÇ¨Ïö©Ïûê ÎèôÍ∏∞Ìôî: ${kcUser.USERNAME} (${kcUser.ID})`);
      } catch (insertError) {
        console.error(`‚ùå ÏÇ¨Ïö©Ïûê ÎèôÍ∏∞Ìôî Ïã§Ìå®: ${kcUser.USERNAME}`, insertError.message);
      }
    }

    console.log(`üéâ ÌÇ§ÌÅ¥ÎùΩ ÎèôÍ∏∞Ìôî ÏôÑÎ£å: ${syncCount}Î™ÖÏùò ÏÉà ÏÇ¨Ïö©Ïûê Ï∂îÍ∞Ä`);
    return syncCount;
  } catch (error) {
    console.error("ÌÇ§ÌÅ¥ÎùΩ ÎèôÍ∏∞Ìôî Ïò§Î•ò:", error);
    throw error;
  }
}

// Í±∞Îûò Í¥ÄÎ†® Ìï®ÏàòÎì§ÏùÑ exportsÏóê Ï∂îÍ∞Ä
module.exports = {
  ...module.exports, // Í∏∞Ï°¥ exports Ïú†ÏßÄ

  // DB ÌíÄÎì§
  pool,           // crypto_data (Í∏∞Î≥∏)
  tradingPool,    // RT_trading_db (Í±∞Îûò Ï†ÑÏö©)
  qnaPool,        // qna (Q&A Ï†ÑÏö©)
  keycloakPool,   // keycloak (ÌÇ§ÌÅ¥ÎùΩ Ï†ÑÏö©)

  // Í±∞Îûò Í¥ÄÎ†® Ìï®ÏàòÎì§ Ï∂îÍ∞Ä
  KRWUtils,
  getUserByUsername,
  getUserBalance,
  getUserTransactions,
  getUserPendingOrders,
  getMarketPendingOrders,
  createPendingOrder,
  cancelPendingOrder,
  executeTradeTransaction,
  processBuyOrder,
  processSellOrder,

  // ÌÇ§ÌÅ¥ÎùΩ ÎèôÍ∏∞Ìôî Ìï®ÏàòÎì§
  getKeycloakUsers,
  getExistingKeycloakUsers,
  syncKeycloakUsers,

  // KRWUtils Ï∂îÍ∞Ä
  KRWUtils
};